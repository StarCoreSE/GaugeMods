using Sandbox.Game.GameSystems.TextSurfaceScripts;using Sandbox.ModAPI;using Sandbox.ModAPI.Interfaces.Terminal;using System;using System.Collections.Generic;using System.Collections.ObjectModel;using System.Linq;using System.Text;using System.Threading.Tasks;using VRage;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.ObjectBuilders;using VRage.Serialization;using VRage.Utils;using VRageMath;using IMyTextSurface=Sandbox.ModAPI.Ingame.IMyTextSurface;namespace Draygo.BlockExtensionsAPI{public class DefinitionExtensionsAPI{public const long MODID=2756894170;IReadOnlyDictionary<Type,Delegate>_methods;Action m_callback=null;bool m_init=false;public bool Init{get{return m_init;}}public DefinitionExtensionsAPI(Action callback){if(MyAPIGateway.Utilities==null)MyAPIGateway.Utilities=MyAPIUtilities.Static;m_callback=callback;MyAPIGateway.Utilities.RegisterMessageHandler(MODID,recieveModHandlers);}public void UnloadData(){MyAPIGateway.Utilities.UnregisterMessageHandler(MODID,recieveModHandlers);}public enum AdditionalMethods:int{None=0,RegisterTSS=1,UnRegisterTSS=2,RegisterDataTSS=3,GetDataTSS=4,DefIDExists=5,GetGroups=6,GetProperties=7,GetAllIndexedIds=8}private void recieveModHandlers(object obj){if(Init)return;try{IReadOnlyDictionary<Type,Delegate>delegates=obj as IReadOnlyDictionary<Type,Delegate>;if(delegates==null)return;_methods=delegates;Assign(typeof(float),ref _floatMethod);Assign(typeof(double),ref _doubleMethod);Assign(typeof(int),ref _intMethod);Assign(typeof(long),ref _longMethod);Assign(typeof(string),ref _textMethod);Assign(typeof(Color),ref _colorMethod);Assign(typeof(bool),ref _booleanMethod);Assign(typeof(Vector2I),ref _vector2IMethod);Assign(typeof(Vector2D),ref _vector2DMethod);Assign(typeof(Vector3I),ref _vector3IMethod);Assign(typeof(Vector3D),ref _vector3DMethod);Assign(typeof(MyGameLogicComponent),ref _setGameLogic);Assign(typeof(Delegate),ref _getDelegate);if(_getDelegate!=null){Assign(AdditionalMethods.RegisterTSS,ref _RegisterTSS);Assign(AdditionalMethods.UnRegisterTSS,ref _UnregisterTSS);Assign(AdditionalMethods.RegisterDataTSS,ref _RegisterTSSDataComponent);Assign(AdditionalMethods.GetDataTSS,ref _GetTSSDataComponent);Assign(AdditionalMethods.DefIDExists,ref _DefIDExists);Assign(AdditionalMethods.GetGroups,ref _GetGroups);Assign(AdditionalMethods.GetProperties,ref _GetProperties);Assign(AdditionalMethods.GetAllIndexedIds,ref _GetAllIndexedIds);}m_init=true;m_callback?.Invoke();}catch(Exception ex){MyLog.Default.WriteLine(@"Error - Below crash is caused by the API mod being the incorrect version. Delete steamapps\workshop\content\244850\2756894170 to force a redownload");throw ex;}}private void Assign<T>(Type valuetype,ref T method)where T:class{method=_methods[valuetype]as T;}private void Assign<T>(AdditionalMethods mt,ref T method)where T:class{method=_getDelegate((int)mt)as T;}private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,float>>_floatMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,double>>_doubleMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,int>>_intMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,long>>_longMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,string>>_textMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,Color>>_colorMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,bool>>_booleanMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,Vector2I>>_vector2IMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,Vector2D>>_vector2DMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,Vector3I>>_vector3IMethod;private Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,Vector3D>>_vector3DMethod;private Action<MyStringId,IMyModContext,Func<MyGameLogicComponent>>_setGameLogic;private Func<int,Delegate>_getDelegate;private Action<MyTSSCommon,IMyTextSurface,IMyTerminalBlock,Action<MyTSSCommon,IMyTerminalBlock,List<IMyTerminalControl>>>_RegisterTSS;private Action<MyTSSCommon,IMyTextSurface,IMyTerminalBlock>_UnregisterTSS;private Action<Type,Type,IMyModContext,Func<MyEntityComponentBase>>_RegisterTSSDataComponent;private Func<Type,IMyTerminalBlock,MyEntityComponentBase>_GetTSSDataComponent;private Func<MyDefinitionId,bool>_DefIDExists;private Action<MyDefinitionId,List<MyStringId>>_GetGroups;private Action<MyDefinitionId,MyStringId,List<MyTuple<MyStringId,Type>>>_GetProperties;private Action<HashSet<MyDefinitionId>>_GetAllIndexedIds;public bool DefinitionIdExists(MyDefinitionId definition){return _DefIDExists?.Invoke(definition)??false;}public void GetAllIndexedIds(HashSet<MyDefinitionId>obj){_GetAllIndexedIds?.Invoke(obj);}public void GetGroups(MyDefinitionId definition,List<MyStringId>grouplist){_GetGroups?.Invoke(definition,grouplist);}public void GetProperties(MyDefinitionId definition,MyStringId groupid,List<MyTuple<MyStringId,Type>>properties){_GetProperties?.Invoke(definition,groupid,properties);}public void RegisterTSS(MyTSSCommon script,IMyTextSurface surface,IMyTerminalBlock block,Action<MyTSSCommon,IMyTerminalBlock,List<IMyTerminalControl>>controlgetter){_RegisterTSS?.Invoke(script,surface,block,controlgetter);}public void UnRegisterTSS(MyTSSCommon script,IMyTextSurface surface,IMyTerminalBlock block){_UnregisterTSS?.Invoke(script,surface,block);}public void RegisterTSSDataComponent<T,U>(IMyModContext modContext,Func<U>customFactory=null)where U:MyEntityComponentBase,new()where T:MyTSSCommon{if(customFactory==null)customFactory=()=>{return new U();};_RegisterTSSDataComponent?.Invoke(typeof(T),typeof(U),modContext,customFactory);}public MyEntityComponentBase GetTSSDataComponent<T>(IMyTerminalBlock block)where T:MyTSSCommon{return _GetTSSDataComponent(typeof(T),block);}public void RegisterGameLogic<T>(MyStringId componentName,IMyModContext mod,Func<T>customFactory=null)where T:MyGameLogicComponent,new(){if(customFactory==null)customFactory=()=>{return new T();};_setGameLogic?.Invoke(componentName,mod,customFactory);}public bool TryGetText(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out string value){var retval=_textMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetString(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out string value){return TryGetText(definition,group,propertyname,out value);}public bool TryGetInt(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out int value){var retval=_intMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetLong(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out long value){var retval=_longMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetFloat(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out float value){var retval=_floatMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetDouble(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out double value){var retval=_doubleMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetBool(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out bool value){var retval=_booleanMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetColor(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out Color value){var retval=_colorMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetVector2I(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out Vector2I value){var retval=_vector2IMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetVector2D(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out Vector2D value){var retval=_vector2DMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetVector3I(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out Vector3I value){var retval=_vector3IMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGetVector3D(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out Vector3D value){var retval=_vector3DMethod.Invoke(definition,group,propertyname);value=retval.Item2;return retval.Item1;}public bool TryGet<T>(MyDefinitionId definition,MyStringId group,MyStringId propertyname,out T value){if(!_methods?.ContainsKey(typeof(T))??false){value=default(T);return false;}var result=((Func<MyDefinitionId,MyStringId,MyStringId,MyTuple<bool,T>>)_methods[typeof(T)]).Invoke(definition,group,propertyname);value=result.Item2;return result.Item1;}}}﻿using System;using System.Collections.Generic;using System.Runtime.CompilerServices;using System.Text;using VRage.Noise.Combiners;using VRageMath;namespace Thermodynamics{internal static class Helper{private const int size=1024;private const int sizeSquared=size*size;public static int Flatten(this Vector3I vector){return(sizeSquared*vector.Z)+(size*vector.Y)+vector.X;}public static Vector3I Unflatten(this Vector3I vector,long flatVector){vector.Z=(int)(flatVector/sizeSquared);flatVector%=sizeSquared;vector.Y=(int)(flatVector/size);vector.X=(int)(flatVector%size);return vector;}}}﻿using System;using System.Collections.Generic;using System.Text;namespace Thermodynamics{public class MyFreeList<TItem>{public TItem[]ItemArray;private int m_size;private readonly Queue<int>m_freePositions;private readonly TItem m_default;public int UsedLength=>m_size;public int Count=>m_size-m_freePositions.Count;public int Capacity=>ItemArray.Length;public MyFreeList(int capacity=16,TItem defaultValue=default(TItem)){ItemArray=new TItem[16];m_freePositions=new Queue<int>(capacity/2);m_default=defaultValue;}public int Allocate(){if(m_freePositions.Count>0){return m_freePositions.Dequeue();}if(m_size==ItemArray.Length){Array.Resize(ref ItemArray,ItemArray.Length<<1);}return m_size++;}public int Allocate(TItem value){int num=Allocate();ItemArray[num]=value;return num;}public void Free(int position){ItemArray[position]=m_default;if(position==m_size){m_size--;}else{m_freePositions.Enqueue(position);}}public TItem[]GetInternalArray(){return ItemArray;}public bool KeyValid(int key){return(uint)key<m_size;}public void Clear(){for(int i=0;i<m_size;i++){ItemArray[i]=default(TItem);}m_size=0;m_freePositions.Clear();}}}﻿using Draygo.BlockExtensionsAPI;using Sandbox.Game.Entities;using Sandbox.ModAPI;using System;using System.Collections.Generic;using System.Drawing;using VRage.Game;using VRage.Game.Components;using VRage.ModAPI;using VRage.Utils;using VRageMath;namespace Thermodynamics{[MySessionComponentDescriptor(MyUpdateOrder.NoUpdate)]public class PlanetManager:MySessionComponentBase{public static readonly double SunSize=0.045f;public static readonly double Denominator=1-SunSize;public static readonly PlanetDefinition NullDef=new PlanetDefinition();public class Planet{public MyPlanet Entity;public Vector3D Position;public MyGravityProviderComponent GravityComponent;private PlanetDefinition definition=NullDef;public PlanetDefinition Definition(){if(definition!=NullDef||!Entity.DefinitionId.HasValue)return definition;definition=PlanetDefinition.GetDefinition(Entity.DefinitionId.Value);MyLog.Default.Info($"[{Settings.Name}] updated planet definition: {Entity.DisplayName}");return definition;}}public class ExternalForceData{public Vector3D Gravity=Vector3D.Zero;public Vector3D WindDirection=Vector3D.Zero;public float WindSpeed;public float AtmosphericPressure;}private static List<Planet>Planets=new List<Planet>();public override void Init(MyObjectBuilder_SessionComponent sessionComponent){MyAPIGateway.Entities.OnEntityAdd+=AddPlanet;MyAPIGateway.Entities.OnEntityRemove+=RemovePlanet;}private void AddPlanet(IMyEntity ent){if(!(ent is MyPlanet))return;MyPlanet entity=(MyPlanet)ent;Planets.Add(new Planet(){Entity=entity,Position=entity.PositionComp.WorldMatrixRef.Translation,GravityComponent=entity.Components.Get<MyGravityProviderComponent>(),});}private void RemovePlanet(IMyEntity ent){Planets.RemoveAll(p=>p.Entity.EntityId==ent.EntityId);}public static ExternalForceData GetExternalForces(Vector3D worldPosition){ExternalForceData data=new ExternalForceData();Planet planet=null;double distance=double.MaxValue;foreach(Planet p in Planets){data.Gravity+=p.GravityComponent.GetWorldGravity(worldPosition);double d=(p.Position-worldPosition).LengthSquared();if(!(d<distance))continue;planet=p;distance=d;}if(planet?.Entity.HasAtmosphere!=true)return data;data.AtmosphericPressure=planet.Entity.GetAirDensity(worldPosition);data.WindSpeed=planet.Entity.GetWindSpeed(worldPosition);return data;}public static Planet GetClosestPlanet(Vector3D position){Planet current=null;double distance=double.MaxValue;for(int i=0;i<Planets.Count;i++){Planet p=Planets[i];double d=(p.Position-position).LengthSquared();if(!(d<distance))continue;current=p;distance=d;}return current;}}}﻿using Draygo.BlockExtensionsAPI;using Sandbox.Game;using Sandbox.Game.Entities;using Sandbox.Game.Entities.Cube;using Sandbox.Game.EntityComponents;using Sandbox.Game.SessionComponents;using Sandbox.ModAPI;using System;using System.Collections.Generic;using System.Net;using System.Text;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.Utils;using VRageMath;namespace Thermodynamics{[MySessionComponentDescriptor(MyUpdateOrder.Simulation)]public class Session:MySessionComponentBase{public static DefinitionExtensionsAPI Definitions;public Session(){MyLog.Default.Info($"[{Settings.Name}] Setup Definition Extention API");Definitions=new DefinitionExtensionsAPI(Done);}private void Done(){MyLog.Default.Info($"[{Settings.Name}] Definition Extention API - Done");}protected override void UnloadData(){Definitions?.UnloadData();base.UnloadData();}public Color GetTemperatureColor(float temp){float max=500f;float t=Math.Max(0,Math.Min(max,temp));float red=(t/max);float blue=(1f-(t/max));return new Color(red,0,blue,255);}public override void Simulate(){if(!Settings.Debug||MyAPIGateway.Utilities.IsDedicated)return;MatrixD matrix=MyAPIGateway.Session.Camera.WorldMatrix;Vector3D start=matrix.Translation;Vector3D end=start+(matrix.Forward*15);IHitInfo hit;MyAPIGateway.Physics.CastRay(start,end,out hit);MyCubeGrid grid=hit?.HitEntity as MyCubeGrid;if(grid==null)return;ThermalGrid g=grid.GameLogic.GetAs<ThermalGrid>();Vector3I position=grid.WorldToGridInteger(hit.Position+(matrix.Forward*0.005f));IMySlimBlock block=grid.GetCubeBlock(position);if(block==null)return;ThermalCell c=g.Get(block.Position);if(c==null)return;MyAPIGateway.Utilities.ShowNotification($"[Env] "+$"sim: {Settings.Instance.SimulationSpeed.ToString("n2")} "+$"freq: {Settings.Instance.Frequency.ToString("n2")} "+$"tstep: {Settings.Instance.TimeScaleRatio.ToString("n2")} "+$"ambT: {(g.FrameAmbientTemprature).ToString("n4")} "+$"decay: {g.FrameSolarDecay.ToString("n4")} "+$"wind: {g.FrameWindDirection.Length().ToString("n4")} "+$"isOcc: {g.FrameSolarOccluded}",1,"White");MyAPIGateway.Utilities.ShowNotification($"[Cell] {c.Block.Position} "+$"T: {c.Temperature.ToString("n4")} "+$"dT: {c.DeltaTemperature.ToString("n6")} "+$"Gen: {c.HeatGeneration.ToString("n4")} "+$"ext: {c.ExposedSurfaces.ToString("n4")} "+$"kA: {string.Join(", ",c.kA)}",1,"White");MyAPIGateway.Utilities.ShowNotification($"[Calc] m: {c.Mass.ToString("n0")} "+$"k: {c.Definition.Conductivity} "+$"sh {c.Definition.SpecificHeat} "+$"em {c.Definition.Emissivity} "+$"pwe: {c.Definition.ProducerWasteEnergy} "+$"cwe: {c.Definition.ConsumerWasteEnergy} "+$"tm: {(c.Definition.SpecificHeat*c.Mass).ToString("n0")} "+$"c: {c.C.ToString("n4")} "+$"r: {c.Radiation.ToString("n2")} "+$"rdt: {(c.Radiation*c.ThermalMassInv).ToString("n4")} "+$"prod: {c.EnergyProduction} "+$"cons: {(c.EnergyConsumption+c.ThrustEnergyConsumption)} ",1,"White");int value=g.NodeSurfaces[position];MyAPIGateway.Utilities.ShowNotification($"[Grid] Exterior: {g.ExteriorNodes.Count} "+$"Nodes: {g.NodeSurfaces.Count} "+$"RNodes: {g.Rooms.Count} "+$"sq: {g.SolidQueue.Count} "+$"rq: {g.RoomQueue.Count} "+$"CrawlDone: {g.ThermalCellUpdateComplete} "+$"sbn: {string.Join(", ",c.TouchingSerfacesByNeighbor)}",1,"White");MyAPIGateway.Utilities.ShowNotification($"[Cell] Airtight out: {((value&1<<0)!=0?1:0)}, {((value&1<<1)!=0?1:0)}, {((value&1<<2)!=0?1:0)}, {((value&1<<3)!=0?1:0)}, {((value&1<<4)!=0?1:0)}, {((value&1<<5)!=0?1:0)}, "+$"in: {((value&1<<6)!=0?1:0)}, {((value&1<<7)!=0?1:0)}, {((value&1<<8)!=0?1:0)}, {((value&1<<9)!=0?1:0)}, {((value&1<<10)!=0?1:0)}, {((value&1<<11)!=0?1:0)}",1,"White");}public override void Draw(){if(!Settings.Debug||MyAPIGateway.Utilities.IsDedicated)return;MatrixD matrix=MyAPIGateway.Session.Camera.WorldMatrix;Vector3D start=matrix.Translation;Vector3D end=start+(matrix.Forward*15);IHitInfo hit;MyAPIGateway.Physics.CastRay(start,end,out hit);MyCubeGrid grid=hit?.HitEntity as MyCubeGrid;if(grid==null)return;Vector3I position=grid.WorldToGridInteger(hit.Position+(matrix.Forward*0.005f));ThermalGrid g=grid.GameLogic.GetAs<ThermalGrid>();IMySlimBlock block=grid.GetCubeBlock(position);if(block==null)return;ThermalCell c=g.Get(block.Position);if(c==null)return;DrawBillboard(c,matrix);for(int i=0;i<c.Neighbors.Count;i++){ThermalCell n=c.Neighbors[i];DrawBillboard(n,matrix);}}public void DrawBillboard(ThermalCell c,MatrixD cameraMatrix){Vector3D position;c.Block.ComputeWorldCenter(out position);float averageBlockLength=Vector3I.DistanceManhattan(c.Block.Max+1,c.Block.Min)*0.33f;Color color=Tools.GetTemperatureColor(c.Temperature).HSVtoColor();const float distance=0.01f;position=cameraMatrix.Translation+(position-cameraMatrix.Translation)*distance;float scaler=1.2f*c.Grid.Grid.GridSizeHalf*averageBlockLength*distance;MyTransparentGeometry.AddBillboardOriented(MyStringId.GetOrCompute("GaugeThermalTexture"),color,position,cameraMatrix.Left,cameraMatrix.Up,scaler,scaler);}}}﻿using System;using System.Collections.Generic;using System.IO;using System.Xml.Serialization;using ProtoBuf;using Sandbox.ModAPI;using VRage.Game;using VRage.Utils;using VRageMath;namespace Thermodynamics{[ProtoContract]public class Settings{public const string Filename="ThermodynamicsConfig.cfg";public const string Name="Thermodynamics";public const bool Debug=true;public const bool DebugBlockColors=false;internal const float SignificantTempChange=float.Epsilon;public static Settings Instance;public static readonly MyStringHash DefaultSubtypeId=MyStringHash.GetOrCompute("DefaultThermodynamics");[ProtoMember(1)]public int Version;[ProtoMember(5)]public bool EnableSolarHeat;[ProtoMember(10)]public bool EnableDamage;[ProtoMember(15)]public int Frequency;[ProtoMember(16)]public float SimulationSpeed;[ProtoMember(110)]public float SolarEnergy;[ProtoMember(120)]public float EnvironmentalRaycastDistance;[ProtoMember(130)]public float VaccumeRadiationStrength;[ProtoMember(140)]public float PresurizedAtmoConductivity;[ProtoMember(150)]public float PresurizedAtmoSpecificHeat;[XmlIgnore]public float TimeScaleRatio;public static Settings GetDefaults(){Settings s=new Settings{Version=1,EnableSolarHeat=false,EnableDamage=true,Frequency=60,SimulationSpeed=1,SolarEnergy=1000f,EnvironmentalRaycastDistance=5000f,VaccumeRadiationStrength=0.05f,PresurizedAtmoConductivity=0.026f,PresurizedAtmoSpecificHeat=1005,};s.Init();return s;}private void Init(){if(Frequency<1)Frequency=1;TimeScaleRatio=1f/Frequency;}public static Settings Load(){Settings defaults=GetDefaults();Settings settings=defaults;try{if(MyAPIGateway.Utilities.FileExistsInWorldStorage(Filename,typeof(Settings))){MyLog.Default.Info($"[{Name}] Loading saved settings");TextReader reader=MyAPIGateway.Utilities.ReadFileInWorldStorage(Filename,typeof(Settings));string text=reader.ReadToEnd();reader.Close();settings=MyAPIGateway.Utilities.SerializeFromXML<Settings>(text);if(settings.Version!=defaults.Version){MyLog.Default.Info($"[{Name}] Old version updating config {settings.Version}->{GetDefaults().Version}");settings=GetDefaults();Save(settings);}}else{MyLog.Default.Info($"[{Name}] Config file not found. Loading default settings");Save(settings);}}catch(Exception e){MyLog.Default.Info($"[{Name}] Failed to load saved configuration. Loading defaults\n {e.ToString()}");Save(settings);}settings.Init();return settings;}public static void Save(Settings settings){try{MyLog.Default.Info($"[{Name}] Saving Settings");TextWriter writer=MyAPIGateway.Utilities.WriteFileInWorldStorage(Filename,typeof(Settings));writer.Write(MyAPIGateway.Utilities.SerializeToXML(settings));writer.Close();}catch(Exception e){MyLog.Default.Info($"[{Name}] Failed to save settings\n{e.ToString()}");}}}}﻿using Sandbox.Definitions;using Sandbox.Game.EntityComponents;using Sandbox.ModAPI;using System;using System.Collections.Generic;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRageMath;using VRage.GameServices;using VRage.Utils;using SpaceEngineers.Game.ModAPI;using VRage.ModAPI;using Sandbox.Game.Entities;using Sandbox.Game;using VRage.ObjectBuilders;using System.IO.Compression;using VRage.Game.Components.Interfaces;using System.Drawing;using System.Security.AccessControl;using System.Net;using VRageRender.Messages;using static VRage.Game.MyObjectBuilder_CurveDefinition;namespace Thermodynamics{public class ThermalCell{public int Id;public long Frame;public float Temperature;public float LastTemprature;public float DeltaTemperature;public float EnergyProduction;public float EnergyConsumption;public float ThrustEnergyConsumption;public float HeatGeneration;public float C;public float Mass;public float Area;public float ExposedSurfaceArea;public float Radiation;public float ThermalMassInv;public float Boltzmann;public float[]kA;public ThermalGrid Grid;public IMySlimBlock Block;public ThermalCellDefinition Definition;public List<ThermalCell>Neighbors=new List<ThermalCell>();public List<int>TouchingSerfacesByNeighbor=new List<int>();public int ExposedSurfaces=0;private int[]ExposedSurfacesByDirection=new int[6];private Queue<Action>pendingListenerActions=new Queue<Action>();public ThermalCell(ThermalGrid g,IMySlimBlock b){Grid=g;Block=b;Id=b.Position.Flatten();Definition=ThermalCellDefinition.GetDefinition(Block.BlockDefinition.Id);SetupListeners();Mass=Block.Mass;Area=Block.CubeGrid.GridSize*Block.CubeGrid.GridSize;C=1/(Definition.SpecificHeat*Mass*Block.CubeGrid.GridSize);ThermalMassInv=1f/(Definition.SpecificHeat*Mass);Boltzmann=-1*Definition.Emissivity*Tools.BoltzmannConstant;UpdateHeat();}public float PreviousTemperature{get;set;}private void SetupListeners(){if(Block.FatBlock==null)return;IMyCubeBlock fat=Block.FatBlock;if(fat is IMyThrust){IMyThrust thrust=(fat as IMyThrust);thrust.ThrustChanged+=(block,old,current)=>{pendingListenerActions.Enqueue(()=>OnThrustChanged(block,old,current));};OnThrustChanged(thrust,0,thrust.CurrentThrust);}else{fat.Components.ComponentAdded+=(type,component)=>{pendingListenerActions.Enqueue(()=>OnComponentAdded(type,component));};fat.Components.ComponentRemoved+=(type,component)=>{pendingListenerActions.Enqueue(()=>OnComponentRemoved(type,component));};if(fat.Components.Contains(typeof(MyResourceSourceComponent))){fat.Components.Get<MyResourceSourceComponent>().OutputChanged+=(resourceType,oldOutput,source)=>{pendingListenerActions.Enqueue(()=>PowerProducedChanged(resourceType,oldOutput,source));};}if(fat.Components.Contains(typeof(MyResourceSinkComponent))){fat.Components.Get<MyResourceSinkComponent>().CurrentInputChanged+=(resourceType,oldInput,sink)=>{pendingListenerActions.Enqueue(()=>PowerConsumedChanged(resourceType,oldInput,sink));};}}if(fat is IMyPistonBase){(fat as IMyPistonBase).AttachedEntityChanged+=(block)=>{pendingListenerActions.Enqueue(()=>GridGroupChanged(block));};}else if(fat is IMyMotorBase){(fat as IMyMotorBase).AttachedEntityChanged+=(block)=>{pendingListenerActions.Enqueue(()=>GridGroupChanged(block));};}else if(fat is IMyDoor){(fat as IMyDoor).DoorStateChanged+=(state)=>{pendingListenerActions.Enqueue(()=>Grid.UpdateBlockMapping(ref Block));};}else if(fat is IMyLandingGear){IMyLandingGear gear=(fat as IMyLandingGear);gear.StateChanged+=(state)=>{pendingListenerActions.Enqueue(()=>{IMyEntity entity=gear.GetAttachedEntity();ThermalCell c=Grid.Get(gear.Position);if(!(entity is MyCubeGrid)){c.AddAllNeighbors();return;}MyCubeGrid grid=entity as MyCubeGrid;ThermalGrid gtherms=grid.GameLogic.GetAs<ThermalGrid>();Vector3D oldMin=gear.CubeGrid.GridIntegerToWorld(new Vector3I(gear.Min.X,gear.Min.Y,gear.Min.Z));Vector3D oldMax=gear.CubeGrid.GridIntegerToWorld(new Vector3I(gear.Max.X,gear.Max.Y,gear.Min.Z));oldMax+=gear.WorldMatrix.Down*(grid.GridSize+0.2f);Vector3I min=grid.WorldToGridInteger(oldMin);Vector3I max=grid.WorldToGridInteger(oldMax);Vector3I temp=Vector3I.Zero;for(int x=min.X;x<=max.X;x++){temp.X=x;for(int y=min.Y;y<=max.Y;y++){temp.Y=y;for(int z=min.Z;z<=max.Z;z++){temp.Z=z;ThermalCell ncell=gtherms.Get(temp);if(ncell!=null){c.AddNeighbor(ncell);}}}}c.CalculatekA();});};}}private void OnComponentAdded(Type compType,IMyEntityComponentBase component){if(compType==typeof(MyResourceSourceComponent)){((MyResourceSourceComponent)component).OutputChanged+=PowerProducedChanged;}if(compType==typeof(MyResourceSinkComponent)){(component as MyResourceSinkComponent).CurrentInputChanged+=PowerConsumedChanged;}}private void OnComponentRemoved(Type compType,IMyEntityComponentBase component){if(compType==typeof(MyResourceSourceComponent)){(component as MyResourceSourceComponent).OutputChanged-=PowerProducedChanged;}if(compType==typeof(MyResourceSinkComponent)){(component as MyResourceSinkComponent).CurrentInputChanged-=PowerConsumedChanged;}}private void GridGroupChanged(IMyMechanicalConnectionBlock block){ThermalGrid g=block.CubeGrid.GameLogic.GetAs<ThermalGrid>();ThermalCell cell=g.Get(block.Position);if(cell==null)return;if(block.Top==null){for(int i=0;i<cell.Neighbors.Count;i++){ThermalCell ncell=cell.Neighbors[i];if(ncell.Block.CubeGrid==cell.Block.CubeGrid)continue;cell.RemoveNeighbor(ncell);break;}}else{ThermalCell ncell=block.Top.CubeGrid.GameLogic.GetAs<ThermalGrid>().Get(block.Top.Position);cell.AddNeighbor(ncell);}}private void OnThrustChanged(IMyThrust block,float old,float current){MyThrustDefinition def=block.SlimBlock.BlockDefinition as MyThrustDefinition;ThrustEnergyConsumption=def.ForceMagnitude*(block.CurrentThrust/block.MaxThrust);UpdateHeat();}private void PowerConsumedChanged(MyDefinitionId resourceTypeId,float oldInput,MyResourceSinkComponent sink){try{if(resourceTypeId!=MyResourceDistributorComponent.ElectricityId)return;EnergyConsumption=sink.CurrentInputByType(resourceTypeId)*Tools.MWtoWatt;UpdateHeat();}catch{}}private void PowerProducedChanged(MyDefinitionId resourceTypeId,float oldOutput,MyResourceSourceComponent source){try{if(resourceTypeId!=MyResourceDistributorComponent.ElectricityId)return;EnergyProduction=source.CurrentOutputByType(resourceTypeId)*Tools.MWtoWatt;UpdateHeat();}catch{}}public void ClearNeighbors(){for(int i=0;i<Neighbors.Count;i++){ThermalCell ncell=Neighbors[i];int j=ncell.Neighbors.IndexOf(this);if(j==-1)continue;ncell.Neighbors.RemoveAt(j);ncell.TouchingSerfacesByNeighbor.RemoveAt(j);ncell.CalculatekA();}Neighbors.Clear();TouchingSerfacesByNeighbor.Clear();CalculatekA();}public void AddAllNeighbors(){ClearNeighbors();List<IMySlimBlock>neighbors=new List<IMySlimBlock>();Block.GetNeighbours(neighbors);for(int i=0;i<neighbors.Count;i++){IMySlimBlock n=neighbors[i];if(!Contains(n.Position))continue;ThermalCell ncell=Grid.Get(n.Position);AddNeighbor(ncell);}}protected void AddNeighbor(ThermalCell n2){Neighbors.Add(n2);n2.Neighbors.Add(this);int area=FindSurfaceArea(n2);TouchingSerfacesByNeighbor.Add(area);n2.TouchingSerfacesByNeighbor.Add(area);CalculatekA();n2.CalculatekA();}protected int FindSurfaceArea(ThermalCell neighbor){int index=Neighbors.IndexOf(neighbor);int totalArea=0;Vector3I position=Block.Position;List<MyCubeBlockDefinition.MountPoint>mounts=new List<MyCubeBlockDefinition.MountPoint>();MyBlockOrientation orientation=Block.Orientation;MyCubeBlockDefinition def=(MyCubeBlockDefinition)Block.BlockDefinition;MyCubeGrid.TransformMountPoints(mounts,def,def.MountPoints,ref orientation);Vector3I nposition=neighbor.Block.Position;List<MyCubeBlockDefinition.MountPoint>neighborMounts=new List<MyCubeBlockDefinition.MountPoint>();MyBlockOrientation neighborOrientation=neighbor.Block.Orientation;MyCubeBlockDefinition neighborDef=(MyCubeBlockDefinition)neighbor.Block.BlockDefinition;MyCubeGrid.TransformMountPoints(neighborMounts,neighborDef,neighborDef.MountPoints,ref neighborOrientation);Vector3I p=nposition-position;for(int i=0;i<mounts.Count;i++){MyCubeBlockDefinition.MountPoint a=mounts[i];if(!a.Enabled){continue;}Vector3 min=Vector3.Min(a.Start,a.End);Vector3 max=Vector3.Max(a.Start,a.End);min-=(Vector3)p;max-=(Vector3)p;BoundingBox mainBox=new BoundingBox(min,max);for(int j=0;j<neighborMounts.Count;j++){MyCubeBlockDefinition.MountPoint b=neighborMounts[j];if(!b.Enabled){continue;}BoundingBox neighborBox=new BoundingBox(Vector3.Min(b.Start,b.End),Vector3.Max(b.Start,b.End));if(!mainBox.Intersects(neighborBox))continue;BoundingBox box=mainBox.Intersect(neighborBox);Vector3I va=new Vector3I((int)Math.Round(box.Max.X-box.Min.X),(int)Math.Round(box.Max.Y-box.Min.Y),(int)Math.Round(box.Max.Z-box.Min.Z));int area=(va.X==0)?1:va.X;area*=(va.Y==0)?1:va.Y;area*=(va.Z==0)?1:va.Z;totalArea+=area;}}return totalArea;}protected void CalculatekA(){kA=new float[Neighbors.Count];for(int i=0;i<Neighbors.Count;i++){float area=Math.Min(Area,Neighbors[i].Area);kA[i]=Definition.Conductivity*area*TouchingSerfacesByNeighbor[i];}}protected void RemoveNeighbor(ThermalCell n2){int i=Neighbors.IndexOf(n2);if(i!=-1){Neighbors.RemoveAt(i);TouchingSerfacesByNeighbor.RemoveAt(i);CalculatekA();}int j=n2.Neighbors.IndexOf(this);if(i==-1)return;n2.Neighbors.RemoveAt(j);n2.TouchingSerfacesByNeighbor.RemoveAt(j);n2.CalculatekA();}public float GetTemperature(){return Temperature;}private void UpdateHeat(){float produced=EnergyProduction*Definition.ProducerWasteEnergy;float consumed=(EnergyConsumption+ThrustEnergyConsumption)*Definition.ConsumerWasteEnergy;HeatGeneration=Settings.Instance.TimeScaleRatio*(produced+consumed)*ThermalMassInv;}internal void Update(){try{while(pendingListenerActions.Count>0){try{Action action=pendingListenerActions.Dequeue();action.Invoke();}catch(Exception ex){MyLog.Default.Error($"Error processing thermal listener action: {ex}");}}UpdateFrameAndLastTemperature();float totalRadiation=CalculateTotalRadiation();float deltaTemperature=CalculateDeltaTemperature();ApplyTemperatureChanges(totalRadiation,deltaTemperature);UpdateHeatGeneration();ApplyHeatGeneration();HandleCriticalTemperature();UpdateDebugVisuals();}catch(Exception ex){MyLog.Default.Error($"Error in thermal cell update: {ex}");}}private void UpdateFrameAndLastTemperature(){Frame=Grid.SimulationFrame;LastTemprature=Temperature;}private float CalculateTotalRadiation(){float temperatureSquared=Temperature*Temperature;float totalRadiation=Boltzmann*Definition.Emissivity*(temperatureSquared*temperatureSquared)-Grid.FrameAmbientTempratureP4;if(!Settings.Instance.EnableSolarHeat||Grid.FrameSolarOccluded)return totalRadiation;float intensity=DirectionalRadiationIntensity(ref Grid.FrameSolarDirection,ref Grid.SolarRadiationNode);totalRadiation+=Settings.Instance.SolarEnergy*Definition.Emissivity*(intensity*ExposedSurfaceArea);return totalRadiation;}private float CalculateDeltaTemperature(){float deltaTemperature=0f;float currentTemperature=Temperature;for(int i=0;i<Neighbors.Count;i++){float neighborTemp=Neighbors[i].Frame==Frame?Neighbors[i].LastTemprature:Neighbors[i].Temperature;deltaTemperature+=kA[i]*(neighborTemp-currentTemperature);}return deltaTemperature;}private void ApplyTemperatureChanges(float totalRadiation,float deltaTemperature){DeltaTemperature=(C*deltaTemperature+totalRadiation*ThermalMassInv)*Settings.Instance.TimeScaleRatio;Temperature=Math.Max(0,Temperature+DeltaTemperature);}private void UpdateHeatGeneration(){HeatGeneration=Settings.Instance.TimeScaleRatio*((EnergyProduction*Definition.ProducerWasteEnergy)+((EnergyConsumption+ThrustEnergyConsumption)*Definition.ConsumerWasteEnergy))*ThermalMassInv;}private void ApplyHeatGeneration(){Temperature+=HeatGeneration;}private void HandleCriticalTemperature(){if(Settings.Instance.EnableDamage&&Temperature>Definition.CriticalTemperature){Block.DoDamage((Temperature-Definition.CriticalTemperature)*Definition.CriticalTemperatureScaler,MyStringHash.GetOrCompute("thermal"),false);}}private void UpdateDebugVisuals(){if(!Settings.DebugBlockColors||!MyAPIGateway.Session.IsServer)return;Vector3 color=Tools.GetTemperatureColor(Temperature);if(Block.ColorMaskHSV!=color){Block.CubeGrid.ColorBlocks(Block.Min,Block.Max,color);}}private void ResetExposedSurfaces(){ExposedSurfaces=0;ExposedSurfacesByDirection=new int[6];}private Dictionary<Vector3I,float>internalRoomTemperatures=new Dictionary<Vector3I,float>();private Dictionary<Vector3I,RoomData>internalRooms=new Dictionary<Vector3I,RoomData>();private const float ROOM_TEMPERATURE_EXCHANGE_RATE=0.1f;private const float ROOM_HEAT_CAPACITY=1005f;private const float ROOM_AIR_DENSITY=1.225f;private struct RoomData{public float Temperature;public float Volume;public float ThermalMass;public HashSet<Vector3I>Nodes;public RoomData(float temp,float vol,HashSet<Vector3I>nodes){Temperature=temp;Volume=vol;Nodes=nodes;ThermalMass=ROOM_HEAT_CAPACITY*ROOM_AIR_DENSITY*Volume;}}private void HandleInternalRooms(Vector3I nodeNei){if(!internalRooms.ContainsKey(nodeNei)){HashSet<Vector3I>roomNodes=new HashSet<Vector3I>();FindConnectedInternalNodes(nodeNei,roomNodes);float roomVolume=roomNodes.Count*Block.CubeGrid.GridSize*Block.CubeGrid.GridSize*Block.CubeGrid.GridSize;float averageTemp=CalculateRoomAverageTemperature(roomNodes);internalRooms[nodeNei]=new RoomData(averageTemp,roomVolume,roomNodes);}RoomData roomData=internalRooms[nodeNei];float surfaceArea=Block.CubeGrid.GridSize*Block.CubeGrid.GridSize;float heatTransferCoefficient=5.0f;float heatTransferred=heatTransferCoefficient*surfaceArea*(Temperature-roomData.Temperature)*Settings.Instance.TimeScaleRatio;float blockTemperatureChange=heatTransferred/(Definition.SpecificHeat*Mass);Temperature-=blockTemperatureChange;float roomTemperatureChange=heatTransferred/roomData.ThermalMass;roomData.Temperature+=roomTemperatureChange;internalRooms[nodeNei]=roomData;if(Grid.SimulationFrame%60==0){EqualizeConnectedRooms(nodeNei);}}private void EqualizeConnectedRooms(Vector3I node){RoomData currentRoom;if(!internalRooms.TryGetValue(node,out currentRoom))return;HashSet<Vector3I>checkedNodes=new HashSet<Vector3I>();Queue<Vector3I>toCheck=new Queue<Vector3I>();toCheck.Enqueue(node);while(toCheck.Count>0){Vector3I currentNode=toCheck.Dequeue();if(!checkedNodes.Add(currentNode))continue;foreach(Vector3I direction in Base6Directions.IntDirections){Vector3I neighborNode=currentNode+direction;RoomData neighborRoom;if(!internalRooms.TryGetValue(neighborNode,out neighborRoom))continue;if(currentRoom.Temperature!=neighborRoom.Temperature){float totalThermalMass=currentRoom.ThermalMass+neighborRoom.ThermalMass;float equalizedTemp=(currentRoom.Temperature*currentRoom.ThermalMass+neighborRoom.Temperature*neighborRoom.ThermalMass)/totalThermalMass;currentRoom.Temperature=equalizedTemp;neighborRoom.Temperature=equalizedTemp;internalRooms[node]=currentRoom;internalRooms[neighborNode]=neighborRoom;}toCheck.Enqueue(neighborNode);}}}private void FindConnectedInternalNodes(Vector3I start,HashSet<Vector3I>roomNodes){Queue<Vector3I>queue=new Queue<Vector3I>();queue.Enqueue(start);while(queue.Count>0){Vector3I current=queue.Dequeue();if(!roomNodes.Add(current))continue;foreach(Vector3I direction in Base6Directions.IntDirections){Vector3I neighbor=current+direction;if(Grid.Grid.CubeExists(neighbor)||Contains(neighbor))continue;if(Grid.ExteriorNodes.Contains(neighbor))continue;queue.Enqueue(neighbor);}}}private float CalculateRoomAverageTemperature(HashSet<Vector3I>roomNodes){float totalTemp=0;int contributingBlocks=0;foreach(Vector3I node in roomNodes){foreach(Vector3I direction in Base6Directions.IntDirections){Vector3I blockPos=node+direction;if(Contains(blockPos))continue;ThermalCell cell=Grid.Get(blockPos);if(cell==null)continue;totalTemp+=cell.Temperature;contributingBlocks++;}}return contributingBlocks>0?totalTemp/contributingBlocks:Grid.FrameAmbientTemprature;}public void UpdateSurfaces(ref HashSet<Vector3I>exterior,ref Dictionary<Vector3I,int>nodeSurfaces){ResetExposedSurfaces();Vector3I min=Block.Min;Vector3I size=Block.Max-min+Vector3I.One;int xMask=(1<<size.X)-1;int yMask=(1<<size.Y)-1;int zMask=(1<<size.Z)-1;int xShiftedMask=xMask<<min.X;int yShiftedMask=yMask<<min.Y;int zShiftedMask=zMask<<min.Z;for(int x=min.X;x<Block.Max.X+1;x++){if((1<<x&xShiftedMask)==0)continue;for(int y=min.Y;y<Block.Max.Y+1;y++){if((1<<y&yShiftedMask)==0)continue;for(int z=min.Z;z<Block.Max.Z+1;z++){if((1<<z&zShiftedMask)==0)continue;Vector3I node=new Vector3I(x,y,z);int surfaceBits=nodeSurfaces[node];for(int i=0;i<6;i++){if((surfaceBits&(1<<i))!=0)continue;Vector3I nodeNei=node+Base6Directions.IntDirections[i];if(exterior.Contains(nodeNei)){ExposedSurfaces++;ExposedSurfacesByDirection[i]++;}else{HandleInternalRooms(nodeNei);}}}}}UpdateExposedSurfaceArea();}public bool Contains(Vector3I n){Vector3I relativePos=n-Block.Min;Vector3I size=Block.Max-Block.Min+Vector3I.One;return(relativePos.X&~(size.X-1))==0&&(relativePos.Y&~(size.Y-1))==0&&(relativePos.Z&~(size.Z-1))==0;}private void UpdateExposedSurfaceArea(){ExposedSurfaceArea=ExposedSurfaces*Area;Boltzmann=-1*Definition.Emissivity*Tools.BoltzmannConstant*ExposedSurfaceArea;}internal float DirectionalRadiationIntensity(ref Vector3 targetDirection,ref ThermalRadiationNode node){float intensity=0;MatrixD matrix=Grid.FrameMatrix;bool isCube=(Block.Max-Block.Min).Volume()<=1;for(int i=0;i<ExposedSurfacesByDirection.Length;i++){intensity+=CalculateDirectionIntensity(i,ExposedSurfacesByDirection[i],ref targetDirection,ref node,matrix,isCube);}return intensity;}private float CalculateDirectionIntensity(int directionIndex,int surfaceCount,ref Vector3 targetDirection,ref ThermalRadiationNode node,MatrixD matrix,bool isCube){Vector3I direction=Base6Directions.IntDirections[directionIndex];Vector3D startDirection=Vector3D.Rotate(direction,matrix);float dot=Vector3.Dot(startDirection,targetDirection);dot=Math.Max(0,dot);if(isCube){node.Sides[directionIndex]+=dot*surfaceCount;node.SideSurfaces[directionIndex]+=surfaceCount;return dot;}else{return Math.Min(dot,node.SideAverages[directionIndex]);}}}}﻿using ProtoBuf.Meta;using Sandbox.Definitions;using Sandbox.Engine.Physics;using Sandbox.Engine.Voxels;using Sandbox.Game;using Sandbox.Game.Entities;using Sandbox.Game.EntityComponents;using Sandbox.ModAPI;using SpaceEngineers.Game.ModAPI;using System;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Linq.Expressions;using System.Reflection;using System.Text;using System.Transactions;using System.Xml;using VRage;using VRage.Game;using VRage.Game.Components;using VRage.Game.Entity;using VRage.Game.ModAPI;using VRage.ModAPI;using VRage.ObjectBuilders;using VRage.Utils;using VRage.Voxels;using VRageMath;namespace Thermodynamics{[MyEntityComponentDescriptor(typeof(MyObjectBuilder_CubeGrid),true)]public partial class ThermalGrid:MyGameLogicComponent{static readonly Guid StorageGuid=new Guid("f7cd64ae-9cd8-41f3-8e5d-3db992619343");public MyCubeGrid Grid;public Dictionary<int,int>PositionToIndex=new Dictionary<int,int>();public MyFreeList<ThermalCell>Thermals=new MyFreeList<ThermalCell>();public Dictionary<int,float>RecentlyRemoved=new Dictionary<int,float>();public ThermalRadiationNode SolarRadiationNode=new ThermalRadiationNode();public ThermalRadiationNode WindNode=new ThermalRadiationNode();public byte FrameCount=0;int SimulationIndex=0;int SimulationQuota=0;public float FrameQuota=0;public long SimulationFrame=1;int Direction=1;public bool ThermalCellUpdateComplete=true;public Vector3 FrameWindDirection;public Vector3 FrameSolarDirection;public MatrixD FrameMatrix;public float FrameAmbientTemprature;public float FrameAmbientTempratureP4;public float FrameSolarDecay;public bool FrameSolarOccluded;public override void Init(MyObjectBuilder_EntityBase objectBuilder){base.Init(objectBuilder);if(Settings.Instance==null){Settings.Instance=Settings.GetDefaults();}Grid=this.Entity as MyCubeGrid;if(this.Entity.Storage==null)this.Entity.Storage=new MyModStorageComponent();if(Grid!=null){Grid.OnGridSplit+=GridSplit;Grid.OnGridMerge+=GridMerge;Grid.OnBlockAdded+=BlockAdded;Grid.OnBlockRemoved+=BlockRemoved;}this.NeedsUpdate=MyEntityUpdateEnum.EACH_FRAME|MyEntityUpdateEnum.BEFORE_NEXT_FRAME;}public override bool IsSerialized(){MyLog.Default.Info($"[{Settings.Name}] serializing");Save();return base.IsSerialized();}string Pack(){byte[]bytes=new byte[Thermals.Count*6];int bi=0;for(int i=0;i<Thermals.UsedLength;i++){ThermalCell c=Thermals.ItemArray[i];if(c==null)continue;int id=c.Id;bytes[bi]=(byte)id;bytes[bi+1]=(byte)(id>>8);bytes[bi+2]=(byte)(id>>16);bytes[bi+3]=(byte)(id>>24);short t=(short)c.Temperature;bytes[bi+4]=(byte)t;bytes[bi+5]=(byte)(t>>8);bi+=6;c.PreviousTemperature=c.Temperature;c.Temperature=t;}return Convert.ToBase64String(bytes);}void Unpack(string data){try{byte[]bytes=Convert.FromBase64String(data);for(int i=0;i<bytes.Length;i+=6){int id=bytes[i];id|=bytes[i+1]<<8;id|=bytes[i+2]<<16;id|=bytes[i+3]<<24;int f=bytes[i+4];f|=bytes[i+5]<<8;Thermals.ItemArray[PositionToIndex[id]].Temperature=f;}}catch(Exception){}}void Save(){string data=Pack();MyModStorageComponentBase storage=this.Entity.Storage;storage[StorageGuid]=data;}void Load(){if(this.Entity.Storage.ContainsKey(StorageGuid)){Unpack(this.Entity.Storage[StorageGuid]);}}void BlockAdded(IMySlimBlock b){if(Grid.EntityId!=b.CubeGrid.EntityId){MyLog.Default.Info($"[{Settings.Name}] Adding Skipped - Grid: {Grid.EntityId} BlockGrid: {b.CubeGrid.EntityId} {b.Position}");return;}AddBlockMapping(ref b);ThermalCell cell=new ThermalCell(this,b);cell.AddAllNeighbors();int index=Thermals.Allocate();PositionToIndex.Add(cell.Id,index);Thermals.ItemArray[index]=cell;}void BlockRemoved(IMySlimBlock b){MyLog.Default.Info($"[{Settings.Name}] block removed");if(Grid.EntityId!=b.CubeGrid.EntityId){MyLog.Default.Info($"[{Settings.Name}] Removing Skipped - Grid: {Grid.EntityId} BlockGrid: {b.CubeGrid.EntityId} {b.Position}");return;}RemoveBlockMapping(ref b);int flat=b.Position.Flatten();int index=PositionToIndex[flat];ThermalCell cell=Thermals.ItemArray[index];RecentlyRemoved[cell.Id]=cell.Temperature;cell.ClearNeighbors();PositionToIndex.Remove(flat);Thermals.Free(index);}void GridSplit(MyCubeGrid g1,MyCubeGrid g2){MyLog.Default.Info($"[{Settings.Name}] Grid Split - G1: {g1.EntityId} G2: {g2.EntityId}");ThermalGrid tg1=g1.GameLogic.GetAs<ThermalGrid>();ThermalGrid tg2=g2.GameLogic.GetAs<ThermalGrid>();for(int i=0;i<tg2.Thermals.UsedLength;i++){ThermalCell c=tg2.Thermals.ItemArray[i];if(c==null)continue;float value;if(!tg1.RecentlyRemoved.TryGetValue(c.Id,out value))continue;c.Temperature=value;tg1.RecentlyRemoved.Remove(c.Id);}}void GridMerge(MyCubeGrid g1,MyCubeGrid g2){MyLog.Default.Info($"[{Settings.Name}] Grid Merge - G1: {g1.EntityId} G2: {g2.EntityId}");ThermalGrid tg1=g1.GameLogic.GetAs<ThermalGrid>();ThermalGrid tg2=g2.GameLogic.GetAs<ThermalGrid>();for(int i=0;i<tg2.Thermals.UsedLength;i++){ThermalCell c=tg2.Thermals.ItemArray[i];if(c==null)continue;int id=c.Block.Position.Flatten();int value;if(tg1.PositionToIndex.TryGetValue(id,out value)){tg1.Thermals.ItemArray[value].Temperature=c.Temperature;}}}public override void UpdateOnceBeforeFrame(){if(Grid.Physics==null){this.NeedsUpdate=MyEntityUpdateEnum.NONE;}Load();PrepareNextSimulationStep();SimulationQuota=GetSimulationQuota();}public override void UpdateBeforeSimulation(){try{FrameCount++;if(SimulationQuota==0){if(FrameCount>=60){SimulationQuota=GetSimulationQuota();FrameCount=0;FrameQuota=0;}else{return;}}FrameQuota+=GetFrameQuota();int cellCount=Thermals.UsedLength;while(FrameQuota>=1){if(SimulationQuota==0)break;if(SimulationIndex==cellCount||SimulationIndex==-1){if(!ThermalCellUpdateComplete)ThermalCellUpdateComplete=true;SimulationFrame++;MapSurfaces();PrepareNextSimulationStep();Direction*=-1;SimulationIndex+=Direction;}try{ThermalCell cell=Thermals.ItemArray[SimulationIndex];if(cell!=null){if(!ThermalCellUpdateComplete){cell.UpdateSurfaces(ref ExteriorNodes,ref NodeSurfaces);}cell.Update();}}catch(Exception ex){MyLog.Default.Error($"Error updating thermal cell at index {SimulationIndex}: {ex}");}FrameQuota--;SimulationQuota--;SimulationIndex+=Direction;}}catch(Exception ex){MyLog.Default.Error($"Critical error in thermal grid update: {ex}");}}void PrepareNextSimulationStep(){Vector3D position=Grid.PositionComp.WorldAABB.Center;PrepareEnvironmentTemprature(ref position);PrepareSolarEnvironment(ref position);}void PrepareEnvironmentTemprature(ref Vector3D position){PlanetManager.Planet planet=PlanetManager.GetClosestPlanet(position);if(planet==null)return;bool isUnderground=false;PlanetDefinition def=planet.Definition();Vector3 local=position-planet.Position;Vector3D surfacePointLocal=planet.Entity.GetClosestSurfacePointLocal(ref local);isUnderground=local.LengthSquared()<surfacePointLocal.LengthSquared();float airDensity=planet.Entity.GetAirDensity(position);float windSpeed=planet.Entity.GetWindSpeed(position);float ambient=def.UndergroundTemperature;if(!isUnderground){float dot=(float)Vector3D.Dot(Vector3D.Normalize(local),FrameSolarDirection);ambient=def.NightTemperature+(dot+1f)*0.5f*(def.DayTemperature-def.NightTemperature);}else{float distanceToCore=(float)local.Length();float coreTemp=def.CoreTemperature;float surfaceDistance=(float)surfacePointLocal.Length();float depthRatio=1-(distanceToCore/surfaceDistance);ambient=def.UndergroundTemperature+(coreTemp-def.UndergroundTemperature)*depthRatio;FrameSolarOccluded=true;}FrameAmbientTemprature=Math.Max(2.7f,ambient*airDensity);float frameAmbiSquared=FrameAmbientTemprature*FrameAmbientTemprature;FrameAmbientTempratureP4=frameAmbiSquared*frameAmbiSquared;FrameSolarDecay=1-def.SolarDecay*airDensity;}void PrepareSolarEnvironment(ref Vector3D position){if(!Settings.Instance.EnableSolarHeat)return;SolarRadiationNode.Update();FrameSolarOccluded=false;FrameSolarDirection=MyVisualScriptLogicProvider.GetSunDirection();FrameMatrix=Grid.WorldMatrix;const double maxSolarDistance=15000000;const int rayCastDistance=28;LineD solarRay=new LineD(position,position+FrameSolarDirection*(float)maxSolarDistance);List<MyLineSegmentOverlapResult<MyEntity>>results=new List<MyLineSegmentOverlapResult<MyEntity>>(32);MyGamePruningStructure.GetTopmostEntitiesOverlappingRay(ref solarRay,results);results.Sort((a,b)=>a.Distance.CompareTo(b.Distance));foreach(var result in results){MyEntity entity=result.Element;if(entity?.Physics==null)continue;MyPlanet planet=entity as MyPlanet;if(planet!=null){if(CheckPlanetOcclusion(ref position,planet)){FrameSolarOccluded=true;break;}continue;}MyVoxelBase voxel=entity as MyVoxelBase;if(voxel!=null&&!(voxel.RootVoxel is MyPlanet)){if(CheckVoxelOcclusion(ref solarRay,voxel,rayCastDistance)){FrameSolarOccluded=true;break;}continue;}MyCubeGrid grid=entity as MyCubeGrid;if(grid==null)continue;if(!CheckGridOcclusion(ref solarRay,grid))continue;FrameSolarOccluded=true;break;}DrawDebugLines(ref position,ref solarRay);}private bool CheckPlanetOcclusion(ref Vector3D position,MyPlanet planet){Vector3D planetLocal=position-planet.PositionComp.WorldMatrixRef.Translation;double distance=planetLocal.Length();if(distance>planet.AverageRadius*2)return false;Vector3D planetDirection=planetLocal/distance;double dot=Vector3D.Dot(planetDirection,FrameSolarDirection);double occlusionDot=Tools.GetLargestOcclusionDotProduct(Tools.GetVisualSize(distance,planet.AverageRadius));return dot<occlusionDot;}private bool CheckVoxelOcclusion(ref LineD ray,MyVoxelBase voxel,int raycastDistance){LineD subLine;voxel.PositionComp.WorldAABB.Intersect(ref ray,out subLine);if(Settings.Debug&&!MyAPIGateway.Utilities.IsDedicated){Vector4 green=Color.Green.ToVector4();MySimpleObjectDraw.DrawLine(subLine.From,subLine.To,MyStringId.GetOrCompute("Square"),ref green,0.2f);}IHitInfo hit;MyAPIGateway.Physics.CastRay(subLine.From,subLine.To,out hit,raycastDistance);return hit!=null;}private bool CheckGridOcclusion(ref LineD ray,MyCubeGrid grid){if(grid.EntityId==Grid.EntityId)return false;List<MyCubeGrid>connectedGrids=new List<MyCubeGrid>();grid.GetConnectedGrids(GridLinkTypeEnum.Physical,connectedGrids);for(int i=0;i<connectedGrids.Count;i++){if(connectedGrids[i].EntityId==Grid.EntityId)return false;}LineD subLine;grid.PositionComp.WorldAABB.Intersect(ref ray,out subLine);if(Settings.Debug&&!MyAPIGateway.Utilities.IsDedicated){Vector4 blue=Color.Blue.ToVector4();MySimpleObjectDraw.DrawLine(subLine.From,subLine.To,MyStringId.GetOrCompute("Square"),ref blue,0.2f);}Vector3I?hit=grid.RayCastBlocks(subLine.From,subLine.To);return hit.HasValue;}private void DrawDebugLines(ref Vector3D position,ref LineD solarRay){if(!Settings.Debug||MyAPIGateway.Utilities.IsDedicated)return;Vector4 rayColor=FrameSolarOccluded?Color.Red.ToVector4():Color.White.ToVector4();MySimpleObjectDraw.DrawLine(position,solarRay.To,MyStringId.GetOrCompute("Square"),ref rayColor,0.1f);}public int GetSimulationQuota(){return Math.Max(1,(int)(Thermals.UsedLength*Settings.Instance.SimulationSpeed*Settings.Instance.Frequency));}public float GetFrameQuota(){return 0.00000001f+Thermals.UsedLength*Settings.Instance.SimulationSpeed*Settings.Instance.Frequency/60f;}public ThermalCell Get(Vector3I position){int flat=position.Flatten();int value;return PositionToIndex.TryGetValue(flat,out value)?Thermals.ItemArray[value]:null;}}}﻿using ProtoBuf.Meta;using Sandbox.Definitions;using Sandbox.Game;using Sandbox.Game.Entities;using Sandbox.Game.EntityComponents;using Sandbox.ModAPI;using SpaceEngineers.Game.ModAPI;using System;using System.Collections.Generic;using VRage.Game;using System.Diagnostics;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.ModAPI;using VRage.Utils;using VRageMath;using System.Linq;using System.Runtime.CompilerServices;using VRageRender;namespace Thermodynamics{public partial class ThermalGrid:MyGameLogicComponent{private Vector3I min;private Vector3I max;public int CurrentRoomId=1;public int NodeCountPerFrame=1;public bool NodeUpdateComplete=false;public Queue<Vector3I>ExteriorQueue=new Queue<Vector3I>();public Queue<Vector3I>SolidQueue=new Queue<Vector3I>();public Queue<Vector3I>RoomQueue=new Queue<Vector3I>();public Dictionary<Vector3I,int>NodeSurfaces=new Dictionary<Vector3I,int>();public HashSet<Vector3I>ExteriorNodes=new HashSet<Vector3I>();public HashSet<Vector3I>SolidNodes=new HashSet<Vector3I>();public Dictionary<Vector3I,int>Rooms=new Dictionary<Vector3I,int>();private void AddBlockMapping(ref IMySlimBlock block){ResetSpacialMapping();Vector3I min=block.Min;Vector3I max=block.Max+1;Vector3I[]neighbors=Base6Directions.IntDirections;Queue<Vector3I>processQueue=new Queue<Vector3I>();MyCubeBlockDefinition def=block.BlockDefinition as MyCubeBlockDefinition;bool isAirtight=def?.IsAirTight==true;Matrix matrix;block.Orientation.GetMatrix(out matrix);matrix.TransposeRotationInPlace();MyCubeBlockDefinition.MountPoint[]mountPoints=def.MountPoints;MyLog.Default.Info($"[{Settings.Name}] Block Start");for(int x=min.X;x<max.X;x++){for(int y=min.Y;y<max.Y;y++){for(int z=min.Z;z<max.Z;z++){int state=0;Vector3I node=new Vector3I(x,y,z);if(isAirtight){state=4032;}for(int i=0;i<neighbors.Length;i++){Vector3I n=node+neighbors[i];Vector3I towardSelf=node-n;if(IsAirtight(ref block,ref def,ref node,ref towardSelf,ref matrix)){state|=1<<i+6;}int ns;if(!NodeSurfaces.TryGetValue(n,out ns))continue;state|=((ns&1<<i+6)>>6);processQueue.Enqueue(n);}NodeSurfaces.Add(node,state);}}}while(processQueue.Count!=0){UpdateNodeMapping(processQueue.Dequeue());}}public void UpdateBlockMapping(ref IMySlimBlock block){Vector3I min=block.Min;Vector3I max=block.Max+1;Vector3I[]neighbors=Base6Directions.IntDirections;Queue<Vector3I>processQueue=new Queue<Vector3I>();MyCubeBlockDefinition def=block.BlockDefinition as MyCubeBlockDefinition;bool isAirtight=def?.IsAirTight==true;Matrix matrix;block.Orientation.GetMatrix(out matrix);matrix.TransposeRotationInPlace();for(int x=min.X;x<max.X;x++){for(int y=min.Y;y<max.Y;y++){for(int z=min.Z;z<max.Z;z++){int state=0;Vector3I node=new Vector3I(x,y,z);if(isAirtight){state=4032;}for(int i=0;i<neighbors.Length;i++){Vector3I n=node+neighbors[i];Vector3I towardSelf=node-n;if(IsAirtight(ref block,ref def,ref node,ref towardSelf,ref matrix)){state|=1<<i+6;}int ns;if(!NodeSurfaces.TryGetValue(n,out ns))continue;state|=((ns&1<<i+6)>>6);processQueue.Enqueue(n);}if(NodeSurfaces[node]==state)continue;ResetSpacialMapping();NodeSurfaces[node]=state;}}}while(processQueue.Count!=0){UpdateNodeMapping(processQueue.Dequeue());}}private void RemoveBlockMapping(ref IMySlimBlock block){ResetSpacialMapping();Vector3I min=block.Min;Vector3I max=block.Max+1;Vector3I[]neighbors=Base6Directions.IntDirections;for(int x=min.X;x<max.X;x++){for(int y=min.Y;y<max.Y;y++){for(int z=min.Z;z<max.Z;z++){Vector3I node=new Vector3I(x,y,z);NodeSurfaces.Remove(node);for(int i=0;i<neighbors.Length;i++){Vector3I n=node+neighbors[i];if(n.X>=min.X&&n.Y>=min.Y&&n.Z>=min.Z&&n.X<max.X&&n.Y<max.Y&&n.Z<max.Z||!NodeSurfaces.ContainsKey(n))continue;int oppositeFace=(i%2==0)?i+1:i-1;NodeSurfaces[n]&=~(1<<oppositeFace);}}}}}private void UpdateNodeMapping(Vector3I node){Vector3I[]neighbors=Base6Directions.IntDirections;int state=NodeSurfaces[node];for(int i=0;i<neighbors.Length;i++){Vector3I n=node+neighbors[i];int ns;NodeSurfaces.TryGetValue(n,out ns);state|=((ns&1<<i+6)>>6);}NodeSurfaces[node]=state;}private bool IsAirtight(ref IMySlimBlock block,ref MyCubeBlockDefinition def,ref Vector3I pos,ref Vector3I normal,ref Matrix matrix){if(def.IsAirTight==true)return true;Vector3 position=Vector3.Zero;if(block.FatBlock!=null){position=pos-block.FatBlock.Position;}IMyDoor door=block.FatBlock as IMyDoor;bool isDoorClosed=door!=null&&(door.Status==Sandbox.ModAPI.Ingame.DoorStatus.Closed||door.Status==Sandbox.ModAPI.Ingame.DoorStatus.Closing);Vector3 value=Vector3.Transform(position,matrix)+def.Center;Vector3I roundedValue=Vector3I.Round(value);if(door!=null){switch(def.IsCubePressurized[roundedValue][normal]){case MyCubeBlockDefinition.MyCubePressurizationMark.NotPressurized:return IsDoorAirtight(ref door,ref normal,ref def);case MyCubeBlockDefinition.MyCubePressurizationMark.PressurizedAlways:return true;case MyCubeBlockDefinition.MyCubePressurizationMark.PressurizedClosed:return isDoorClosed;}}else{switch(def.IsCubePressurized[roundedValue][normal]){case MyCubeBlockDefinition.MyCubePressurizationMark.NotPressurized:return false;case MyCubeBlockDefinition.MyCubePressurizationMark.PressurizedAlways:return true;}}return false;}private bool IsDoorAirtight(ref IMyDoor door,ref Vector3I normal,ref MyCubeBlockDefinition def){if(!door.IsFullyClosed)return false;if(door is MyAirtightSlideDoor){if(normal==Vector3I.Forward){return true;}}else if(door is MyAirtightDoorGeneric){if(normal==Vector3I.Forward||normal==Vector3I.Backward){return true;}}MyCubeBlockDefinition.MountPoint[]mountPoints=def.MountPoints;for(int i=0;i<mountPoints.Length;i++){if(normal==mountPoints[i].Normal){return false;}}return true;}public void ResetSpacialMapping(){min=Grid.Min-1;max=Grid.Max+1;CurrentRoomId=0;ExteriorQueue.Clear();ExteriorQueue.Enqueue(min);ExteriorNodes.Clear();SolidQueue.Clear();SolidNodes.Clear();RoomQueue.Clear();Rooms.Clear();NodeCountPerFrame=Math.Max((int)((max-min).Size/60f),1);NodeUpdateComplete=false;}public void MapSurfaces(){int loopCount=0;if(ExteriorQueue.Count>0){CrawlOutside(ref loopCount);}else if(RoomQueue.Count>0||SolidQueue.Count>0){CrawlInside(ref loopCount);}else{NodeUpdateComplete=true;ThermalCellUpdateComplete=false;}}private void CrawlOutside(ref int loopCount){Vector3I[]neighbors=Base6Directions.IntDirections;while(ExteriorQueue.Count>0&&loopCount<NodeCountPerFrame){loopCount++;Vector3I node=ExteriorQueue.Dequeue();for(int i=0;i<6;i++){Vector3I n=node+neighbors[i];if(ExteriorNodes.Contains(n)||Vector3I.Min(n,min)!=min||Vector3I.Max(n,max)!=max)continue;int flag;NodeSurfaces.TryGetValue(n,out flag);int shift=i+6+((i%2==0)?1:-1);if((flag&1<<shift)!=0){continue;}ExteriorQueue.Enqueue(n);ExteriorNodes.Add(n);}}}private void CrawlInside(ref int loopCount){while(true){Vector3I[]neighbors=Base6Directions.IntDirections;while(RoomQueue.Count>0&&loopCount<NodeCountPerFrame){loopCount++;Vector3I node=RoomQueue.Dequeue();int flag;NodeSurfaces.TryGetValue(node,out flag);for(int i=0;i<6;i++){Vector3I n=node+neighbors[i];if(Rooms.ContainsKey(n))continue;if((flag&1<<i)!=0)continue;RoomQueue.Enqueue(n);Rooms.Add(n,CurrentRoomId);}}while(RoomQueue.Count==0&&SolidQueue.Count>0&&loopCount<NodeCountPerFrame){loopCount++;Vector3I node=SolidQueue.Dequeue();int surfaces=NodeSurfaces[node];for(int i=0;i<neighbors.Length;i++){Vector3I n=node+neighbors[i];if(ExteriorNodes.Contains(n)||SolidNodes.Contains(n)||Rooms.ContainsKey(n))continue;if((surfaces&1<<i)==0){RoomQueue.Enqueue(n);Rooms.Add(n,CurrentRoomId++);SolidQueue.Enqueue(node);break;}else{SolidQueue.Enqueue(n);}}}if(loopCount<NodeCountPerFrame&&SolidQueue.Count>0){continue;}break;}}}}﻿using Sandbox.Game.Entities;using System;using System.Collections.Generic;using System.Text;using VRageMath;namespace Thermodynamics{public class ThermalRadiationNode{public float[]Sides=new float[6];public float[]SideAverages=new float[6];public int[]SideSurfaces=new int[6];public void Update(){for(int i=0;i<6;i++){SideAverages[i]=(SideSurfaces[i]>0)?Sides[i]/(float)SideSurfaces[i]:0;}Array.Clear(Sides,0,Sides.Length);Array.Clear(SideSurfaces,0,SideSurfaces.Length);}}}﻿using Sandbox.Game.Entities;using Sandbox.ModAPI;using System;using System.Collections.Generic;using System.Text;using VRage.ModAPI;using VRageMath;namespace Thermodynamics{public class Tools{public const float MWtoWatt=1000000;public const float kWtoWatt=1000;public const float KphToMps=1000f/60f/60f;public const float BoltzmannConstant=0.00000005670374419f;public const float VacuumTemperaturePower4=53.1441f;public const float ConductivityScaler=1f/10000f;public static int DirectionToIndex(Vector3I vector){if(vector.X>0)return 0;if(vector.X<0)return 1;if(vector.Y>0)return 2;if(vector.Y<0)return 3;if(vector.Z>0)return 4;return 5;}public static Vector3 IndexToDirection(int index){switch(index){case 0:return new Vector3(1,0,0);case 1:return new Vector3(-1,0,0);case 2:return new Vector3(0,1,0);case 3:return new Vector3(0,-1,0);case 4:return new Vector3(0,0,1);case 5:return new Vector3(0,0,-1);default:return Vector3.Zero;}}public static Vector3 GetTemperatureColor(float temp,float max=2000,float low=265f,float high=500f){float t=Math.Max(0,Math.Min(max,temp));float h=240f/360f;float s=1;float v=0.5f;if(t<low){v=(1.5f*(t/low))-1;}else if(t<high){h=(240f-((t-low)/(high-low)*240f))/360f;}else{h=0;s=1-(2*((t-high)/(max-high)));}return new Vector3(h,s,v);}public static int FindTouchingSurfaceArea(Vector3I minA,Vector3I maxA,Vector3I minB,Vector3I maxB){if(minA.X==maxB.X||maxA.X==minB.X){int overlapY=Math.Min(maxA.Y,maxB.Y)-Math.Max(minA.Y,minB.Y);int overlapZ=Math.Min(maxA.Z,maxB.Z)-Math.Max(minA.Z,minB.Z);if(overlapY>0&&overlapZ>0){return overlapY*overlapZ;}}if(minA.Y==maxB.Y||maxA.Y==minB.Y){int overlapX=Math.Min(maxA.X,maxB.X)-Math.Max(minA.X,minB.X);int overlapZ=Math.Min(maxA.Z,maxB.Z)-Math.Max(minA.Z,minB.Z);if(overlapX>0&&overlapZ>0){return overlapX*overlapZ;}}if(minA.Z==maxB.Z||maxA.Z==minB.Z){int overlapX=Math.Min(maxA.X,maxB.X)-Math.Max(minA.X,minB.X);int overlapY=Math.Min(maxA.Y,maxB.Y)-Math.Max(minA.Y,minB.Y);if(overlapX>0&&overlapY>0){return overlapX*overlapY;}}return 0;}public static bool IsSolarOccluded(Vector3D observer,Vector3 solarDirection,MyPlanet planet){Vector3D local=observer-planet.PositionComp.WorldMatrixRef.Translation;double distance=local.Length();Vector3D localNorm=local/distance;double dot=Vector3.Dot(localNorm,solarDirection);return dot<GetLargestOcclusionDotProduct(GetVisualSize(distance,planet.AverageRadius));}public static double GetVisualSize(double distance,double radius){return 2*Math.Atan(radius/(2*distance));}public static double GetLargestOcclusionDotProduct(double visualSize){return-1+(0.85*visualSize*visualSize*visualSize);}}}﻿using Sandbox.Definitions;using Sandbox.ModAPI;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.ObjectBuilders;using VRage.Utils;namespace Thermodynamics{[MyEntityComponentDescriptor(typeof(MyObjectBuilder_CubeBlock),true,"Gauge_LG_CoolantPipe_Straight")]public class CoolantPipe:MyGameLogicComponent{public override void Init(MyObjectBuilder_EntityBase objectBuilder){IMyCubeBlock block=(this.Entity as IMyCubeBlock);MyCubeBlockDefinition def=block.SlimBlock.BlockDefinition as MyCubeBlockDefinition;MyLog.Default.Info("TEST!!!!! "+def.MountPoints.Count().ToString());}}}﻿using Draygo.BlockExtensionsAPI;using ProtoBuf;using System;using System.Collections.Generic;using System.Text;using VRage.Game;using VRage.Utils;namespace Thermodynamics{[ProtoContract]public class PlanetDefinition{private static readonly MyStringId GroupId=MyStringId.GetOrCompute("ThermalPlanetProperties");private static readonly MyStringId NightTemperatureId=MyStringId.GetOrCompute("NightTemperature");private static readonly MyStringId DayTemperatureId=MyStringId.GetOrCompute("DayTemperature");private static readonly MyStringId UndergroundTemperatureId=MyStringId.GetOrCompute("UndergroundTemperature");private static readonly MyStringId CoreTemperatureId=MyStringId.GetOrCompute("CoreTemperature");private static readonly MyStringId SealevelDeadzoneId=MyStringId.GetOrCompute("SealevelDeadzone");private static readonly MyStringId SolarDecayId=MyStringId.GetOrCompute("SolarDecay");private static readonly MyStringId AtmoConductivityId=MyStringId.GetOrCompute("AtmoConductivity");private static readonly MyStringId AtmoDensityId=MyStringId.GetOrCompute("AtmoDensity");[ProtoMember(10)]public float NightTemperature;[ProtoMember(15)]public float DayTemperature;[ProtoMember(17)]public float UndergroundTemperature;[ProtoMember(20)]public float CoreTemperature;[ProtoMember(25)]public float SealevelDeadzone;[ProtoMember(30)]public float SolarDecay;[ProtoMember(40)]public float AtmoConductivity;[ProtoMember(50)]public float AtmoDensity;public static PlanetDefinition GetDefinition(MyDefinitionId defId){MyLog.Default.Info($"[{Settings.Name}] Planet Definition: {defId}");PlanetDefinition def=new PlanetDefinition();DefinitionExtensionsAPI lookup=Session.Definitions;if(!lookup.DefinitionIdExists(defId)){defId=new MyDefinitionId(typeof(MyObjectBuilder_PlanetGeneratorDefinition),Settings.DefaultSubtypeId);}double dvalue;if(lookup.TryGetDouble(defId,GroupId,NightTemperatureId,out dvalue))def.NightTemperature=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,DayTemperatureId,out dvalue))def.DayTemperature=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,UndergroundTemperatureId,out dvalue))def.UndergroundTemperature=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,CoreTemperatureId,out dvalue))def.CoreTemperature=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,SealevelDeadzoneId,out dvalue))def.SealevelDeadzone=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,SolarDecayId,out dvalue))def.SolarDecay=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,AtmoConductivityId,out dvalue))def.AtmoConductivity=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,AtmoDensityId,out dvalue))def.AtmoDensity=(float)dvalue;return def;}}}﻿using System;using System.Collections.Generic;using System.Text;using System.Xml.Serialization;using Draygo.BlockExtensionsAPI;using ProtoBuf;using VRage.Game;using VRage.Utils;namespace Thermodynamics{[ProtoContract]public class ThermalCellDefinition{private static readonly MyStringId GroupId=MyStringId.GetOrCompute("ThermalBlockProperties");private static readonly MyStringId ConductivityId=MyStringId.GetOrCompute("Conductivity");private static readonly MyStringId SpecificHeatId=MyStringId.GetOrCompute("SpecificHeat");private static readonly MyStringId EmissivityId=MyStringId.GetOrCompute("Emissivity");private static readonly MyStringId ProducerWasteEnergyId=MyStringId.GetOrCompute("ProducerWasteEnergy");private static readonly MyStringId ConsumerWasteEnergyId=MyStringId.GetOrCompute("ConsumerWasteEnergy");private static readonly MyStringId CriticalTemperatureId=MyStringId.GetOrCompute("CriticalTemperature");private static readonly MyStringId CriticalTemperatureScalerId=MyStringId.GetOrCompute("CriticalTemperatureScaler");private static readonly MyDefinitionId DefaultCubeBlockDefinitionId=new MyDefinitionId(typeof(MyObjectBuilder_EnvironmentDefinition),Settings.DefaultSubtypeId);[ProtoMember(1)]public float Conductivity;[ProtoMember(10)]public float SpecificHeat;[ProtoMember(15)]public float Emissivity;[ProtoMember(20)]public float ProducerWasteEnergy;[ProtoMember(30)]public float ConsumerWasteEnergy;[ProtoMember(40)]public float CriticalTemperature;[ProtoMember(45)]public float CriticalTemperatureScaler;public static ThermalCellDefinition GetDefinition(MyDefinitionId defId){ThermalCellDefinition def=new ThermalCellDefinition();DefinitionExtensionsAPI lookup=Session.Definitions;if(!lookup.DefinitionIdExists(defId)){defId=new MyDefinitionId(defId.TypeId,Settings.DefaultSubtypeId);if(!lookup.DefinitionIdExists(defId)){defId=DefaultCubeBlockDefinitionId;}}double dvalue;if(lookup.TryGetDouble(defId,GroupId,ConductivityId,out dvalue))def.Conductivity=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,SpecificHeatId,out dvalue))def.SpecificHeat=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,EmissivityId,out dvalue))def.Emissivity=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,ProducerWasteEnergyId,out dvalue))def.ProducerWasteEnergy=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,ConsumerWasteEnergyId,out dvalue))def.ConsumerWasteEnergy=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,CriticalTemperatureId,out dvalue))def.CriticalTemperature=(float)dvalue;if(lookup.TryGetDouble(defId,GroupId,CriticalTemperatureScalerId,out dvalue))def.CriticalTemperatureScaler=(float)dvalue;def.Conductivity=Math.Max(0,def.Conductivity);def.SpecificHeat=Math.Max(0,def.SpecificHeat);def.Emissivity=Math.Max(0,def.Emissivity);def.ProducerWasteEnergy=Math.Max(0,def.ProducerWasteEnergy);def.ConsumerWasteEnergy=Math.Max(0,def.ConsumerWasteEnergy);def.CriticalTemperature=Math.Max(0,def.CriticalTemperature);def.CriticalTemperatureScaler=Math.Max(0,Math.Min(1,def.CriticalTemperatureScaler));return def;}}}
